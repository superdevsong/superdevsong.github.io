---
title: "Java 정리"
categories:
  -  Java
tags:
  - Java
---


### Goal
 * Java의 구조와 작동하는 원리에 대해서 설명해보자.

### 배경

어느 면접 준비 포스트를 보는데 그중에서 내가 대답할수 있는게 많이 없었다.

그러니 나도 한번 정리를 해 보고자 해서 이 글을 쓰게됬다.

## 자바의 특징

Java는 객체지향 프로그래밍 언어다.

물론 함수형 프로그래밍 페러다임도 지원은 한다만 사용해보면서 느낀것은 그것의 근간도 결국 객체라는것

기본 자료형을 제외한 모든 요소들이 객체로 표현되고, 객체 지향 개념의 특징인 캡슐화, 상속, 다형성이 잘 적용된 언어다.

JVM(자바 가상 머신) 위에서 동작하기 때문에 운영체제에 독립적이다(물론 jvm은 운영체제에 종속적)

garbage collector를 통한 자동적인 메모리 관리가 가능하다.

JVM 위에서 동작하기 때문에 실행 속도가 상대적으로 느리다.(물론 Jit Compiler라는 해결방안이 있긴 하지만 그래도 상대적으로 느린편)


## jre와 jdk

jre에 jvm과 java api들이 있으며 Jdk에는 자바 컴파일러와 여러가지 자바툴이 있다.

## Jvm 

Jvm은 스택기반으로 동작하며, 바이트코드를 os에 맞게 해석 해주는 역할을 하고 가비지컬렉션을 통해 자동적인 메모리 관리를 해준다.

다음 설명에서 jvm의 구성요소들의 동작과정을 더 자세히 설명하겠다.

## java 컴파일부터 실행과정

작성된 코드(.java)를 자바 컴파일러가 자바 바이트 코드(.class)로 변환한뒤

class loader가 작성된 class 파일을 jvm Runtime data area로 로딩

java runtime data area에 적재된 데이터를 excution engine에서 클래스파일을 바이너리 코드로 변환하여 실행이 이루어짐

이 3개는 Jvm의 주요 구성요소중 하나다.

## 불변 객체 

불변 객체는 객체 생성 이후 내부가 변하지 않는 객체를 말함

자바 필드가 원시타입인 경우 final 키워드를 사용해 불변 객체로 만들수 있다.

참조 타입인 경우 

일반 객체라면 안에있는 모든 필드의 final 키워드를 선언하는 방법이 있고

리스트나 배열일 경우는 그대로 파라미터로 주는 방식으로 하지 말고 clone을 만들어야 한다.

이러한 불변객체를 사용하는 이유는 멀티스레딩에 있어서 Thread-safe라는 이점을 가져 동기화를 고려하지 않아도 된다.

부수효과의 피해 오류를 최소화 할 수 있다.

## 가비지 컬렉션

가비지 컬렉션은 jvm의 구성요소중 하나로 jvm의 메모리 관리 기법으로 사용되고 있다. 동적으로 할당된 객체 즉 메모리 영역중에서 사용하지 않는것울 회수하는 메모리 관리 기법이다.

GC의 작업을 수행하기 위해 Jvm 어플리케이션의 실행을 잠시 멈추고 스택을 조사해 힙 영역에 있는 객체와 연결된 변수가 있는 경우 해당 객체를 마킹한 후 객체 마킹 작업이 끝났다면 마킹되지 않은 부분의 메모리를 회수한다.

이렇게 잠시 멈추는 작업을 Stop The World라 하고 마킹과 메모리회수 작업을 Mark and Sweep이라한다.

참고로 힙 영역은 영 제네레이션과 올드 제네레이션으로 나뉜다. 

영 제네레이션 같은 경우 또 에덴 서바이버0 서바이버1로 나뉜다.

각 구역이 꽉찰때마다 Mark and Sweep이 일어나는데 이 작업 이후 살아있는 메모리는 다음 영역으로 가게 된다.

즉 에덴 -> 서바이버 0 -> 서바이버 1 -> 올드 제네레이션 순으로 일어난다.

왜 그렇게 할까? 이유는 gc설계자들은 대부분의 가비지 컬렉터는 영제네레이션 즉 금방 일어난다고 생각하기 때문이다.

그래서 두 영역을 나누고 영 제네레이션에서만 주로 가비지 컬렉터를 진행하고 대부분의 메모리 낭비를 잡는다.

## 자바의 메모리 영역

jvm에서 메모리 영역으로 실행되는 어플리케이션의 데이터들이 적재된다.

Method Area 모든 쓰레드가 공유하는 영역으로 static변수, 클래스, 인터페이스 등등의 존재하며 포로그램의 시작부터 종료까지 메모리에 남아있다.

Heap Area 이 역시 메모리 내에 모든 쓰레드가 공유하는 영역으로 객체와 배열이 생성되는 영역이다. 또한 가비지 컬렉터에 의해 메모리 관리가 이루어진다.

Stack Area 각 쓰레드마다 이 영역을 가지고 있으며 메서드 호출시마다 스택 프레임이 쌓이고 메서드에서 사용하는 각종 지역변수, 매개변수 리턴값 등이 임시로 저장이 되었다가 메서드가 끝남과 동시에 해당 프레임별로 삭제된다. 호출과 삭제 방식은 선입후출이다.

Pc Register Thread가 시작될때 생성된다. 각 쓰레드마다 하나씩 존재하며 쓰레드가 어떤 명령을 내릴지에 대해서 기록해두고 있으며 현재 수행중인 jvm의 명령주소를 가르친다.

Native Stack  자바 이외의 언어에서 작성된 네이티브 코드를 실행할때 사용되는 영역 

## new String()과 리터럴의 차이 

new String으로 스트링을 생성할 경우 새로운 객체가 생성되며 힙 메모리 영역에 저장된다.

그러나 리터럴은 힙에 있는 String Constant Pool에 저장되어 공유가 가능하다.

즉 new String으로 같은 문자열을 생성했다면 이는 같은것으로 간주하지 않지만 리터럴로 같은 문자열을 생성하면 공유된 자원을 사용해 같다고 나온다.

```java
String s1 = new String("1234");
String s2 = new String("1234");
System.out.println(s1==s2); // false

String s3 = "1234";
String s4 = "1234";
System.out.println(s1==s2);//true

```

## String, StringBuilder, StringBuffer

String은 불변 객체로 StringBuilder와 StringBuffer는 가변 객체다.

StringBuffer는 동기화를 지원해 멀티 쓰레드 환경에서 주로 쓰이며,

StringBuilder는 동기화를 지원하지 않아 싱글 쓰레드 환경에서 주로 쓰인다.(stringbuffer에비해 고려할게 적어 성능이 더 좋다고하다.)

## Inner 클래스의 장점과 로딩 시점은?

내부 클래스에서 외부클래스의 멤버의 손쉽게 접근할 수 있다.

이는 관련 클래스를 묶어 응집도를 높이므로 코드의 질이 높아진다. 

로딩시점은 외부클래스가 로딩될때 될거같지만 이는 내부에 선언되어 외부자원을 손쉽게 할당할 수 있을뿐 또 다른 클래스이므로 이 클래스가 직접 사용될때 로딩된다.


## Reflection은 무엇인가?

리플렉션은 클래스의 구체적인 타입을 몰라도 그 클래스의 멤버 변수 메소드에 접근할 수 있게 도와주는 자바 api다.

리플렉션은 사용하는 경우는 위에서 말한대로 구체적인 타입을 모를때다. 예를들어 jdbc 같은 경우 여러 dbms 환경에 따라 사용하는 api가 다른데 이것을 리플렉션을 통해 사용할 클래스를 동적으로 로딩시켜 활용할 수 있다. 

## 직렬화란?

자바 시스템 내부에서 사용되는 객체와 데이터를 외부에서 사용할 수 있게 바이트 형태로 변환하는것을 말한다.

byte로 변환된 데이터를 다시 객체나 내부 데이터로 변환하는것은 역직렬화라 한다.

직렬화를 할 때는 SerialVersionUID의 선언을 권장하고 있으며 이를 선언하지 않을시 클래스의 정의가 바뀔때 역직렬화를 못하는 사태가 발생할 수 있다.


참고 : 

[자바 면접질문](https://dev-coco.tistory.com/153#%F-%-F%--%A-%--String%-C%--StringBuffer%-C%--StringBuilder%EC%-D%--%--%EC%B-%A-%EC%-D%B-%EB%A-%BC%--%EC%--%A-%EB%AA%--%ED%--%B-%EC%A-%BC%EC%--%B-%EC%-A%---)

[동적인 클래스 로딩](https://javacan.tistory.com/entry/1)

[문자열](https://dev.to/composite/string-2l5a)

[가변 불변 객체](https://steady-coding.tistory.com/559)

[직렬화](https://techblog.woowahan.com/2550/)