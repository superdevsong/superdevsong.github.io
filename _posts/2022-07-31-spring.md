---
title: "Spring 정리"
categories:
  -  Spring
tags:
  - Java
---


### Goal
 * 스프링의 구조와 작동하는 원리에 대해서 설명해보자.

### 배경

이 역시 스프링의 원리와 구조에 대해서 좀 부족했던거 같아서 이참에 모아서 정리해보고자 했다.

## 스프링이란

옛날 포스팅에서도 설명해본적 있지만 한번더 말하자면 자바에서 개발할때 간단한 POJO형태의 개발을 도와 개발자에게 편의성을 제공해주는 프레임워크다.

대표적으로 세가지 특징을 갖는데 

첫번재 IOC(저에의 역전) 제어의 주체가 사용자가 아닌 프레임워크로 사용자에게 몇몇 클래스, 메타정보를 제공받아 이를 바탕으로 프로세스를 제어한다.

두번째 DI(의존성 주입) IOC 컨테이너에서 서로 의존성을 가지는 객체가 있다면 의존성 주입을 해준다.

여기서 의존성이란 연관관계를 갖거나 혹은 인터페이스와 구현체와 상속관계와 같은 서로 관계를 갖을때를 말한다.

세번째 AOP 트랜잭션, 로깅과 같은 공통 로직을 핵심 로직에서 분리해준다.


## 스프링부트와 스프링의 차이

스프링부트는 스프링에 비해 좀 더 웹 환경에 맞춰 특화된 프레임워크다. 내장톰캣을 가지고 있으며 기타 configurarion을 자동으로 해주고 있다.


## 스프링 MVC란?

MVC란 프로그램을 model view controller로 분리하여 개발하는 소프트웨어 디자인 패턴이다.

model : 프로그램의 Db 데이터관리 비즈니스 로직을 처리한다(DAO,DTO,Service)

view : 처리된 비즈니스 로직을 바탕으로 UI를 구성하는 표현구간(html,mustache,tymeleaf 등 화면을 구성하기도 하고, api 서버로 구현된다면 json형태의 응답을 한다.)

controller : 사용자의 요청을 처리하며 model과 view를 제어하는 중개역할을 한다.

###  처리과정

1. 클라이언트에서 url을 통해 요청을 보낸다.

2. 디스패처 서블릿은 핸들러 매핑을 통해 해당 요청이 어느 컨트롤러에 대한 요청인지 찾는다.

3. 디스패처 서블릿은 핸들러 어댑터에게 요청의 전달을 맡겨서 컨트롤러에게 요청을 전달한다.

4. 컨트롤러는 모델(DAO,Service)등을 활용해 비즈니스 로직을 처리한 후 반환할 뷰의 이름을 반환한다.

5. 디스패처 서블릿은 ViewResolver를 통해 반활할 뷰를 찾고 뷰에 핵심로직에서 처리한 데이터를 추가해 반환한다.




## 서블릿이란?

자바에서 웹을 구현하기 위해 필요한 기술로 클라이언트에 요청을 처리를 도와주는 HttpServlet을 상속하는 구현체다.

실질적으로 이 일을 하기위해서는 이러한 정의해놓은 서블릿을 관리해주는 서블릿 컨테이너가 필요하다. 서블릿 컨테이너는 클라이언트의 요청(Request)을 받아주고 응답(Response)할 수 있게, 웹서버와 소켓으로 통신해준다 대표적인 예로 톰캣이 있다.

서블릿이 요청을 받고 처리하는 과정을 이해하면 더 쉽게 알수있다. 

과정은 다음과 같다.

1. 클라이언트 요청을 서블릿 컨테이너가 받는다 이때  HttpServletRequest와 HttpServletResponse 객체를 생성한다.

2. 그리고 web.xml에 있는 메타정보를 보며 어느 url을 통해 어느 서블릿에 대한 요청인지 찾는다.

3. 서블릿을 찾으면 해당 요청에 대한처리를 위임한다.

4. 서블릿은 service() 메서드를 호출해 해당 요청에 대해 http 메서드에 따라 doget dopost로 처리한다.

5. 응답이 끝나면 생성한 HttpServletRequest와 HttpServletResponse 두 객체를 소멸시킨다. 

처리하는 과정에서 HttpServletRequest request를 바탕으로 필요한 정보를 받고 HttpServletResponse를 통해 응답할 내용을 정의할것이다.



## 디스패처 서블릿 

앞서 말한 서블릿 컨테이너의 역할을 위임받는 서블릿이다. 

서블릿 컨테이너에 오는 요청을 모두 디스패처 서블릿이 받아서 해당 컨트롤러를 찾아 처리한다.

즉 원래는 서블릿 컨테이너에 web.xml에 처리할 여러 서블릿을 등록했지만 이제는 디스패처 서블릿 하나만 두고 처리한다는것

이는 만약 모든 서블릿에 공통적으로 처리해야될 사항이 있다면 큰 편의성을 제공할 수 있다.

## @Transactional의 동작원리 

사실 이게 동작원리가 뭐가 있나 싶었다. 그냥 있으면 저장할수있고 그런거아냐 싶었는데 아니였다.

트랜잭션은 crud작업과 더불어 작업이 성공적으로 완료되면 commit하고 실패하면 rollback 하는 전체적인 과정 즉 Db의 작업단위다.

스프링은 aop를 지원하는데 aop는 이런 트랜잭션 작업이나, 로깅, 보안 작업과 같은 공통적으로 하는 작업을 핵심 비즈니스 로직에서 분리하는것이다.

내가 jpa를 사용하면서 느낀것은 저 트랜잭션이란 작업을 내가 jpa를 사용하면서 정의해준거 아니야? 였다.

곰곰히 생각해보자 나는 분명히 crud를 코드를 통해서 사용하였지만 아니다. 롤백이나 커밋에대한 자세한 처리는 하지 않았다.

이러한 처리를 @Transactional을 통해서 aop를 활용해 해준것이다.

정확히 말하면 @Transactional을 사용함으로써 타겟인 객체를 상속하는 proxy객체를 동적으로 만들어 그안에서 타겟메소드 전후로 트랜잭션 작업을 한다.

여기서 유의할 점은 동일한 빈에서의 Transactional 메서드 호출은 프록시가 사용되지 않으니 @Transactional의 사용할 지점을 잘 정해야된다.



참고 :

[스프링 면접질문 ](https://dev-coco.tistory.com/163#%F-%-F%--%A-%--%EC%--%-C%EB%B-%--%EB%A-%BF%EC%-D%--%--%EB%-F%--%EC%-E%--%--%EB%B-%A-%EC%-B%-D%EC%--%--%--%EB%-C%--%ED%--%B-%--%EC%--%A-%EB%AA%--%ED%--%B-%EC%A-%BC%EC%--%B-%EC%-A%---)

[dispatcher servlet](https://creampuffy.tistory.com/172)

[servlet ](https://mangkyu.tistory.com/14)

[Transactional 원리1](https://hwannny.tistory.com/98)

[Transactional 원리2](https://oopsys.tistory.com/276)

[동일한빈](https://cheese10yun.github.io/spring-transacion-same-bean/)













